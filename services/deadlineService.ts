
import {
  ClaimState,
  Deadline,
  DeadlineType,
  DeadlinePriority,
  DeadlineStatus,
  TimelineEvent,
  CalendarEvent,
  PartyType,
  DocumentType
} from '../types';
import { UK_LEGAL_DEADLINES, DEFAULT_REMINDER_DAYS } from '../constants';
import { getLbaResponsePeriodDays } from './legalRules';
import { formatDateISO, isValidDate } from '../utils/formatters';

// ==========================================
// Helper Functions
// ==========================================

/**
 * Add days to a date
 */
const addDays = (date: Date, days: number): Date => {
  const result = new Date(date);
  result.setDate(result.getDate() + days);
  return result;
};

/**
 * Generate a unique deadline ID
 */
const generateDeadlineId = (): string => {
  return `dl_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
};

/**
 * Format date to ISO date string (YYYY-MM-DD) using local timezone
 */
const formatDate = (date: Date): string => {
  return formatDateISO(date);
};

/**
 * Get days until a deadline
 * Returns 0 if the date is invalid
 */
export const getDaysUntilDeadline = (dueDate: string): number => {
  if (!isValidDate(dueDate)) return 0;

  const today = new Date();
  today.setHours(0, 0, 0, 0);
  const due = new Date(dueDate);
  due.setHours(0, 0, 0, 0);
  return Math.ceil((due.getTime() - today.getTime()) / (1000 * 60 * 60 * 24));
};

// ==========================================
// Priority Calculation
// ==========================================

/**
 * Calculate deadline priority based on days remaining
 * CRITICAL: overdue or due today
 * HIGH: 1-3 days
 * MEDIUM: 4-7 days
 * LOW: >7 days
 */
export const calculateDeadlinePriority = (dueDate: string): DeadlinePriority => {
  const daysUntil = getDaysUntilDeadline(dueDate);

  if (daysUntil <= 0) return DeadlinePriority.CRITICAL;
  if (daysUntil <= 3) return DeadlinePriority.HIGH;
  if (daysUntil <= 7) return DeadlinePriority.MEDIUM;
  return DeadlinePriority.LOW;
};

/**
 * Recalculate priority for existing deadlines (should be called periodically)
 */
export const updateDeadlinePriority = (deadline: Deadline): Deadline => {
  return {
    ...deadline,
    priority: calculateDeadlinePriority(deadline.dueDate)
  };
};

// ==========================================
// LBA Response Period Calculation
// ==========================================

/**
 * Get the appropriate LBA response period based on defendant type
 * Consumers (Individuals): 30 days recommended
 * Businesses: 14 days minimum
 *
 * Note: This is a convenience wrapper around getLbaResponsePeriodDays from legalRules
 */
export const getLbaResponsePeriod = (claim: ClaimState): number => {
  // Use the centralized function from legalRules to avoid duplication
  return getLbaResponsePeriodDays(claim.defendant.type);
};

/**
 * Check if LBA response period has expired
 */
export const isLbaExpired = (lbaDate: string, responsePeriod: number = 14): boolean => {
  const expiry = addDays(new Date(lbaDate), responsePeriod);
  return new Date() > expiry;
};

/**
 * Calculate court filing deadline after LBA expires
 */
export const getCourtFilingDeadline = (lbaDate: string, responsePeriod: number): string => {
  const lba = new Date(lbaDate);
  return formatDate(addDays(lba, responsePeriod));
};

// ==========================================
// Deadline Suggestions
// ==========================================

/**
 * Calculate suggested deadlines based on claim state and timeline
 * Returns deadlines that need user confirmation before adding
 */
export const calculateSuggestedDeadlines = (claim: ClaimState): Deadline[] => {
  const suggestions: Deadline[] = [];

  // Check for LBA sent -> suggest response deadline
  const lbaEvent = claim.timeline.find(e => e.type === 'lba_sent');
  if (lbaEvent) {
    const responsePeriod = getLbaResponsePeriod(claim);
    const responseDate = addDays(new Date(lbaEvent.date), responsePeriod);

    // Only suggest if deadline is in the future
    if (responseDate > new Date()) {
      suggestions.push({
        id: generateDeadlineId(),
        claimId: claim.id,
        type: DeadlineType.LBA_RESPONSE,
        title: 'LBA Response Period Expires',
        description: `The ${responsePeriod}-day response period for the Letter Before Action expires. If no response is received, you may proceed to court action.`,
        dueDate: formatDate(responseDate),
        priority: calculateDeadlinePriority(formatDate(responseDate)),
        status: DeadlineStatus.PENDING,
        createdAt: new Date().toISOString(),
        autoGenerated: true,
        sourceEvent: lbaEvent.description,
        legalReference: 'Pre-Action Protocol for Debt Claims',
        reminderDays: DEFAULT_REMINDER_DAYS,
      });
    }

    // Also suggest court filing deadline (response period + 1 day)
    const courtFilingDate = addDays(responseDate, 1);
    if (courtFilingDate > new Date()) {
      suggestions.push({
        id: generateDeadlineId(),
        claimId: claim.id,
        type: DeadlineType.COURT_FILING,
        title: 'Court Filing Available (N1)',
        description: `You may now file a court claim (Form N1) if no satisfactory response was received to your LBA.`,
        dueDate: formatDate(courtFilingDate),
        priority: calculateDeadlinePriority(formatDate(courtFilingDate)),
        status: DeadlineStatus.PENDING,
        createdAt: new Date().toISOString(),
        autoGenerated: true,
        sourceEvent: lbaEvent.description,
        legalReference: 'CPR Part 7 - How to Start Proceedings',
        reminderDays: DEFAULT_REMINDER_DAYS,
      });
    }
  }

  // Check for payment due event in timeline -> suggest follow-up
  const paymentDueEvent = claim.timeline.find(e => e.type === 'payment_due');
  if (paymentDueEvent) {
    const paymentDate = new Date(paymentDueEvent.date);

    // If payment is overdue, suggest sending a chaser (7 days after due)
    const chaserDate = addDays(paymentDate, 7);
    if (chaserDate > new Date() && !claim.timeline.some(e => e.type === 'chaser')) {
      suggestions.push({
        id: generateDeadlineId(),
        claimId: claim.id,
        type: DeadlineType.PAYMENT_FOLLOW_UP,
        title: 'Send Payment Reminder',
        description: `Consider sending a polite payment reminder if payment has not been received.`,
        dueDate: formatDate(chaserDate),
        priority: calculateDeadlinePriority(formatDate(chaserDate)),
        status: DeadlineStatus.PENDING,
        createdAt: new Date().toISOString(),
        autoGenerated: true,
        sourceEvent: paymentDueEvent.description,
        reminderDays: [3, 1, 0],
      });
    }
  }

  // Check invoice due date (separate from timeline payment_due event)
  // This captures cases where due date is set but no timeline event exists
  if (claim.invoice.dueDate && isValidDate(claim.invoice.dueDate)) {
    const dueDate = new Date(claim.invoice.dueDate);
    const today = new Date();

    // If due date is upcoming, suggest a "Payment Due" reminder
    if (dueDate > today && !paymentDueEvent) {
      suggestions.push({
        id: generateDeadlineId(),
        claimId: claim.id,
        type: DeadlineType.PAYMENT_FOLLOW_UP,
        title: 'Invoice Payment Due',
        description: `Payment for invoice ${claim.invoice.invoiceNumber || 'N/A'} is due. Follow up if not received.`,
        dueDate: formatDate(dueDate),
        priority: calculateDeadlinePriority(formatDate(dueDate)),
        status: DeadlineStatus.PENDING,
        createdAt: new Date().toISOString(),
        autoGenerated: true,
        sourceEvent: `Invoice ${claim.invoice.invoiceNumber} due date`,
        reminderDays: [7, 3, 1],
      });
    }

    // If due date has passed, suggest follow-up (7 days after due)
    if (dueDate < today && !paymentDueEvent) {
      const followUpDate = addDays(dueDate, 7);
      if (followUpDate > today && !claim.timeline.some(e => e.type === 'chaser')) {
        suggestions.push({
          id: generateDeadlineId(),
          claimId: claim.id,
          type: DeadlineType.PAYMENT_FOLLOW_UP,
          title: 'Overdue Payment Follow-up',
          description: `Invoice ${claim.invoice.invoiceNumber || 'N/A'} is overdue. Send a payment reminder or chaser.`,
          dueDate: formatDate(followUpDate),
          priority: calculateDeadlinePriority(formatDate(followUpDate)),
          status: DeadlineStatus.PENDING,
          createdAt: new Date().toISOString(),
          autoGenerated: true,
          sourceEvent: `Invoice ${claim.invoice.invoiceNumber} overdue`,
          reminderDays: [3, 1, 0],
        });
      }
    }
  }

  return suggestions;
};

/**
 * Get deadline suggestion for a specific timeline event type
 */
export const getDeadlineFromTimelineEvent = (
  event: TimelineEvent,
  claim: ClaimState
): Deadline | null => {
  switch (event.type) {
    case 'lba_sent': {
      const responsePeriod = getLbaResponsePeriod(claim);
      const responseDate = addDays(new Date(event.date), responsePeriod);
      return {
        id: generateDeadlineId(),
        claimId: claim.id,
        type: DeadlineType.LBA_RESPONSE,
        title: 'LBA Response Period Expires',
        description: `The ${responsePeriod}-day response period expires. You may proceed to court if no response.`,
        dueDate: formatDate(responseDate),
        priority: calculateDeadlinePriority(formatDate(responseDate)),
        status: DeadlineStatus.PENDING,
        createdAt: new Date().toISOString(),
        autoGenerated: true,
        sourceEvent: event.description,
        legalReference: 'Pre-Action Protocol for Debt Claims',
        reminderDays: DEFAULT_REMINDER_DAYS,
      };
    }

    case 'payment_due': {
      // Suggest follow-up 7 days after due date
      const followUpDate = addDays(new Date(event.date), 7);
      return {
        id: generateDeadlineId(),
        claimId: claim.id,
        type: DeadlineType.CUSTOM,
        title: 'Payment Follow-up',
        description: 'Follow up on overdue payment if not received.',
        dueDate: formatDate(followUpDate),
        priority: calculateDeadlinePriority(formatDate(followUpDate)),
        status: DeadlineStatus.PENDING,
        createdAt: new Date().toISOString(),
        autoGenerated: true,
        sourceEvent: event.description,
        reminderDays: [3, 1, 0],
      };
    }

    default:
      return null;
  }
};

// ==========================================
// Filtering & Querying
// ==========================================

/**
 * Get all upcoming deadlines for dashboard widget
 * @param claims All claims in the system (used to filter orphaned deadlines)
 * @param deadlines All deadlines in the system
 * @param days Number of days to look ahead (default 14)
 */
export const getUpcomingDeadlines = (
  claims: ClaimState[],
  deadlines: Deadline[],
  days: number = 14
): Deadline[] => {
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  const cutoff = addDays(today, days);

  // Get claim IDs for validation
  const validClaimIds = new Set(claims.map(c => c.id));

  return deadlines
    .filter(d =>
      d.status === DeadlineStatus.PENDING &&
      new Date(d.dueDate) <= cutoff &&
      validClaimIds.has(d.claimId) // Only include deadlines for existing claims
    )
    .map(d => updateDeadlinePriority(d)) // Update priority
    .sort((a, b) => new Date(a.dueDate).getTime() - new Date(b.dueDate).getTime());
};

/**
 * Get overdue deadlines
 */
export const getOverdueDeadlines = (deadlines: Deadline[]): Deadline[] => {
  const today = new Date();
  today.setHours(0, 0, 0, 0);

  return deadlines
    .filter(d =>
      d.status === DeadlineStatus.PENDING &&
      new Date(d.dueDate) < today
    )
    .sort((a, b) => new Date(a.dueDate).getTime() - new Date(b.dueDate).getTime());
};

/**
 * Get deadlines for a specific claim
 */
export const getDeadlinesForClaim = (
  deadlines: Deadline[],
  claimId: string
): Deadline[] => {
  return deadlines
    .filter(d => d.claimId === claimId)
    .sort((a, b) => new Date(a.dueDate).getTime() - new Date(b.dueDate).getTime());
};

/**
 * Check if a deadline already exists for a specific event
 * (to avoid creating duplicates)
 */
export const hasExistingDeadlineForEvent = (
  deadlines: Deadline[],
  claimId: string,
  type: DeadlineType,
  sourceEvent?: string
): boolean => {
  return deadlines.some(d =>
    d.claimId === claimId &&
    d.type === type &&
    (sourceEvent ? d.sourceEvent === sourceEvent : true)
  );
};

// ==========================================
// Calendar Event Conversion
// ==========================================

/**
 * Convert deadlines to react-big-calendar events
 */
export const deadlinesToCalendarEvents = (
  deadlines: Deadline[],
  claims: ClaimState[]
): CalendarEvent[] => {
  return deadlines
    .filter(deadline => isValidDate(deadline.dueDate))
    .map(deadline => {
      const claim = claims.find(c => c.id === deadline.claimId);
      const dueDate = new Date(deadline.dueDate);

      return {
        id: deadline.id,
        title: `${deadline.title}${claim ? ` - ${claim.defendant.name}` : ''}`,
        start: dueDate,
        end: dueDate,
        allDay: true,
        resource: {
          claimId: deadline.claimId,
          deadlineId: deadline.id,
          type: 'deadline' as const,
          priority: deadline.priority,
          status: deadline.status,
        },
      };
    });
};

/**
 * Convert timeline events to calendar events (for showing claim history)
 */
export const timelineToCalendarEvents = (
  claims: ClaimState[]
): CalendarEvent[] => {
  const events: CalendarEvent[] = [];

  for (const claim of claims) {
    for (const event of claim.timeline) {
      // Skip events with invalid dates
      if (!isValidDate(event.date)) continue;

      const eventDate = new Date(event.date);
      events.push({
        id: `${claim.id}_${event.date}_${event.type}`,
        title: `${event.description} - ${claim.defendant.name}`,
        start: eventDate,
        end: eventDate,
        allDay: true,
        resource: {
          claimId: claim.id,
          type: 'timeline_event' as const,
        },
      });
    }
  }

  return events;
};

// ==========================================
// Deadline Status Updates
// ==========================================

/**
 * Mark a deadline as completed
 */
export const markDeadlineComplete = (deadline: Deadline): Deadline => {
  return {
    ...deadline,
    status: DeadlineStatus.COMPLETED,
    completedAt: new Date().toISOString(),
  };
};

/**
 * Mark a deadline as missed (for overdue uncompleted deadlines)
 */
export const markDeadlineMissed = (deadline: Deadline): Deadline => {
  return {
    ...deadline,
    status: DeadlineStatus.MISSED,
  };
};

/**
 * Snooze a deadline to a future date
 */
export const snoozeDeadline = (deadline: Deadline, newDate: string): Deadline => {
  return {
    ...deadline,
    status: DeadlineStatus.SNOOZED,
    snoozedUntil: newDate,
    dueDate: newDate,
    priority: calculateDeadlinePriority(newDate),
  };
};

/**
 * Create a manual deadline
 */
export const createManualDeadline = (
  claimId: string,
  title: string,
  description: string,
  dueDate: string,
  legalReference?: string
): Deadline => {
  return {
    id: generateDeadlineId(),
    claimId,
    type: DeadlineType.CUSTOM,
    title,
    description,
    dueDate,
    priority: calculateDeadlinePriority(dueDate),
    status: DeadlineStatus.PENDING,
    createdAt: new Date().toISOString(),
    autoGenerated: false,
    legalReference,
    reminderDays: DEFAULT_REMINDER_DAYS,
  };
};

// ==========================================
// Automatic Deadline Generation
// ==========================================

/**
 * Auto-generate deadlines based on document type and claim state.
 * This is the main entry point for automatic deadline creation when documents are generated.
 *
 * @param documentType - The type of document that triggered generation
 * @param claim - Current claim state
 * @param existingDeadlines - Array of existing deadlines to check for duplicates
 * @param triggerDate - Optional date override (defaults to today for LBA, or lbaSentDate if available)
 * @returns Array of newly created deadlines (empty if all duplicates)
 */
export const generateDeadlinesForDocument = (
  documentType: DocumentType,
  claim: ClaimState,
  existingDeadlines: Deadline[],
  triggerDate?: string
): Deadline[] => {
  const newDeadlines: Deadline[] = [];
  const today = formatDate(new Date());

  switch (documentType) {
    case DocumentType.LBA:
    case DocumentType.POLITE_CHASER: {
      // For LBA: Generate LBA Response + Court Filing deadlines
      const lbaDate = triggerDate || claim.lbaSentDate || today;
      const responsePeriod = getLbaResponsePeriod(claim);
      const responseDate = addDays(new Date(lbaDate), responsePeriod);

      // LBA Response Deadline
      if (!hasExistingDeadlineForEvent(existingDeadlines, claim.id, DeadlineType.LBA_RESPONSE)) {
        newDeadlines.push({
          id: generateDeadlineId(),
          claimId: claim.id,
          type: DeadlineType.LBA_RESPONSE,
          title: 'LBA Response Period Expires',
          description: `The ${responsePeriod}-day response period for the Letter Before Action expires. If no response is received, you may proceed to court action.`,
          dueDate: formatDate(responseDate),
          priority: calculateDeadlinePriority(formatDate(responseDate)),
          status: DeadlineStatus.PENDING,
          createdAt: new Date().toISOString(),
          autoGenerated: true,
          sourceEvent: `LBA sent on ${lbaDate}`,
          legalReference: 'Pre-Action Protocol for Debt Claims',
          reminderDays: DEFAULT_REMINDER_DAYS,
        });
      }

      // Court Filing Available Deadline (response period + 1 day)
      const courtFilingDate = addDays(responseDate, 1);
      if (!hasExistingDeadlineForEvent(existingDeadlines, claim.id, DeadlineType.COURT_FILING)) {
        newDeadlines.push({
          id: generateDeadlineId(),
          claimId: claim.id,
          type: DeadlineType.COURT_FILING,
          title: 'Court Filing Available (N1)',
          description: `You may now file a court claim (Form N1) if no satisfactory response was received to your LBA.`,
          dueDate: formatDate(courtFilingDate),
          priority: calculateDeadlinePriority(formatDate(courtFilingDate)),
          status: DeadlineStatus.PENDING,
          createdAt: new Date().toISOString(),
          autoGenerated: true,
          sourceEvent: `LBA response period expired`,
          legalReference: 'CPR Part 7 - How to Start Proceedings',
          reminderDays: DEFAULT_REMINDER_DAYS,
        });
      }
      break;
    }

    case DocumentType.FORM_N1: {
      // For N1: Generate Acknowledgment + Defence deadlines
      // Service date is typically when claim is served on defendant
      const serviceDate = triggerDate || today;

      // Acknowledgment of Service Deadline (14 days from service)
      if (!hasExistingDeadlineForEvent(existingDeadlines, claim.id, DeadlineType.ACKNOWLEDGMENT)) {
        const ackDate = addDays(new Date(serviceDate), UK_LEGAL_DEADLINES.ACKNOWLEDGMENT_PERIOD);
        newDeadlines.push({
          id: generateDeadlineId(),
          claimId: claim.id,
          type: DeadlineType.ACKNOWLEDGMENT,
          title: 'Defendant Acknowledgment Deadline',
          description: `The defendant has ${UK_LEGAL_DEADLINES.ACKNOWLEDGMENT_PERIOD} days from service to file an acknowledgment of service. If no acknowledgment or defence is filed, you may apply for default judgment.`,
          dueDate: formatDate(ackDate),
          priority: calculateDeadlinePriority(formatDate(ackDate)),
          status: DeadlineStatus.PENDING,
          createdAt: new Date().toISOString(),
          autoGenerated: true,
          sourceEvent: `N1 Claim Form generated on ${serviceDate}`,
          legalReference: 'CPR Part 10 - Acknowledgment of Service',
          reminderDays: DEFAULT_REMINDER_DAYS,
        });
      }

      // Defence Filing Deadline (28 days total from service if no acknowledgment)
      if (!hasExistingDeadlineForEvent(existingDeadlines, claim.id, DeadlineType.DEFENCE_DEADLINE)) {
        const defenceDate = addDays(new Date(serviceDate), UK_LEGAL_DEADLINES.DEFENCE_PERIOD_TOTAL);
        newDeadlines.push({
          id: generateDeadlineId(),
          claimId: claim.id,
          type: DeadlineType.DEFENCE_DEADLINE,
          title: 'Defence Filing Deadline',
          description: `The defendant has ${UK_LEGAL_DEADLINES.DEFENCE_PERIOD_TOTAL} days from service to file a defence (or ${UK_LEGAL_DEADLINES.DEFENCE_PERIOD_AFTER_ACK} days after acknowledgment). After this deadline passes without a defence, you may apply for default judgment.`,
          dueDate: formatDate(defenceDate),
          priority: calculateDeadlinePriority(formatDate(defenceDate)),
          status: DeadlineStatus.PENDING,
          createdAt: new Date().toISOString(),
          autoGenerated: true,
          sourceEvent: `N1 Claim Form generated on ${serviceDate}`,
          legalReference: 'CPR Part 15 - Defence and Reply',
          reminderDays: DEFAULT_REMINDER_DAYS,
        });
      }
      break;
    }

    case DocumentType.DEFAULT_JUDGMENT: {
      // For N225: Generate Enforcement Available deadline
      const judgmentDate = triggerDate || today;

      if (!hasExistingDeadlineForEvent(existingDeadlines, claim.id, DeadlineType.ENFORCEMENT)) {
        const enforcementDate = addDays(new Date(judgmentDate), UK_LEGAL_DEADLINES.ENFORCEMENT_WAIT_AFTER_JUDGMENT);
        newDeadlines.push({
          id: generateDeadlineId(),
          claimId: claim.id,
          type: DeadlineType.ENFORCEMENT,
          title: 'Enforcement Action Available',
          description: `You may now commence enforcement action if the judgment has not been satisfied. Options include High Court Enforcement, County Court bailiffs, or attachment of earnings.`,
          dueDate: formatDate(enforcementDate),
          priority: calculateDeadlinePriority(formatDate(enforcementDate)),
          status: DeadlineStatus.PENDING,
          createdAt: new Date().toISOString(),
          autoGenerated: true,
          sourceEvent: `Default judgment obtained on ${judgmentDate}`,
          legalReference: 'CPR Part 70 - General Rules about Enforcement',
          reminderDays: [7, 3, 1, 0],
        });
      }
      break;
    }

    default:
      // No automatic deadlines for other document types
      break;
  }

  return newDeadlines;
};
